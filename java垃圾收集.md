1. 判断回收对象
    1. 引用计数器算法
        1. 很难解决循环引用问题
    2. 可达性分析算法
        1. 通过一系列称为 GC Roots的对象作为起始点，从这些节点向下搜索。如果对象无法到达，则对象不可用  
        
        
2. java引用类型
    1. 强引用，不会被回收
    2. 软引用，第二次回收时会被回收
    3. 弱引用，第一次就会被回收
    4. 虚引用，虚引用不会对对象产生任何影响，只能在这个对象被回收时得到一个系统通知    

    
3. 对象回收过程
    见java垃圾收集.vpp
    

4. 方法区也可以被回收

5. 标记-清除算法
    1. 回收过程
        1. 标记：通过可达性分析
        2. 回收
    2. 不足
        1. 效率低
        2. 空间问题：标记清除之后会产生大量不连续的内存碎片
        
6. 复制算法
    1. 回收过程
        将内存分为大小相等的两块，每次只使用其中一半。回收时，将存活对象复制到另一半内存上。然后将原来的一半内存全部清理。
    2. 现在的商业虚拟机采用这种方法来回收新生代
    3. 不足
        1. 浪费空间
        2. 当存活对象很多时，对象复制操作效率变低
    
7. 标记-整理算法
    1. 把存活对象向一端移动聚集，然后清理分界点之外的内存
    
8. 分代收集算法   
    1. 根据对象存活周期的不同将内存划分为几块。一半分为新生代和老年代。然后分别采用各自最合适的算法。
    2. 新生代采用复制算法
    3. 老年代采用标记-清理或者标记-整理方法 
    
9. HotSport开始回收的过程
    1. 枚举根节点
        1. OopMap
    2. 安全点
    3. 安全区域           
    
