1. 类与类加载器
    1. 每一个类加载器都拥有的自己加载的类。相同的类由不同的类加载器加载后并不相等
    
2. 类加载器
    1. 虚拟机角度
        1. 启动类加载器(BootStrap ClassLoader)。是虚拟机的一部分
        2. 其他类加载器。由Java实现，独立于虚拟机，并且都继承抽象java.lang.ClassLoader  
    2. 开发人员角度
        1. 启动类加载器(BootStrap ClassLoader)  
            无法被Java程序直接引用，加载JAVA_HOME/lib目录，且被虚拟机识别(按照文件名识别, rt.jar)的类库加载到虚拟机内存。
        2. 扩展类加载器(Extension ClassLoader)  
            加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
        3. 应用程序加载器(Application ClassLoader)
            这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统类加载器。负责加载用户类路径(ClassPath)上的所指定的类库。程序中默认的类加载器  
            
            
3. 双亲委派模型
    1. 启动类加载器<--扩展类加载器<--应用程序类加载器<--自定义类加载器
    2. 类加载器之间的父子关系一般不会以继承的关系来实现，而是通过组合的方式来复用父加载器的代码
    3. 当类加载收到类加载请求时，它首先将请求转发给父类加载器，当父类加载器不能加载类时，才会自己去加载。因此所有的类加载请求都会转发给BootStrap ClassLoader
    4. 例如java.lang.Object类，存放于rt.jar中，因此无论哪个类加载器加载，最终都由启动类加载器加载，这样保证系统中只有一个java.lang.Object类
    5. 双亲委派很好的解决了各个类加载器的基础类的统一问题，越基础的类由越上层的类加载器加载  
    

4. 破坏双亲委派模型  
    1. 第一次破坏
    2. 第二次破坏
        JNDI服务，基础类需要调用用户的代码。父类加载器请求子类加载器完成类加载动作。
    3. 第三次破坏
        代码热替换，模块热部署  